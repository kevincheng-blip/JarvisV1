# 滾動式分析 × J-GOD 系統對映關係

> **整理日期**：2024-11-28  
> **來源文件**：`docs/滾動式分析.txt` / `docs/滾動式分析_AI知識庫版_v1.md`

---

## 📚 核心概念概述

「滾動式分析」定義了 J-GOD 系統的**「時間機器」**核心框架，確保系統能夠：
- 在歷史回測中模擬真實實戰環境（無數據洩漏）
- 優化 AI Token 成本（訊號預生成與集中式模型迭代）
- 實現智慧學習與自我修復（故障隔離、動態觸發、影子學習）
- 達到機構級別的嚴謹性（延遲獨立樣本測試、滑價模擬、數據洩漏防護）

---

## 🔄 核心概念 × J-GOD 系統對映

### 一、三階段實施路線圖

#### Phase 1：規則＋因子 Walk-Forward（當前階段）

**核心概念**：
- 不動用 RL，先用簡單規則串接因子
- 驗證因子本身是否有效

**J-GOD 系統對映**：

| 系統模組 | 對應功能 | 狀態 |
|---------|---------|------|
| `pipeline/walk_forward_simulator.py` | Walk-Forward 核心執行器 | ✅ 已實作（Step 7） |
| `pipeline/walk_forward_config.py` | 時間切片配置 | ✅ 已實作（Step 7） |
| `pipeline/data_loader.py` | 因子快取載入介面 | ✅ 已實作（Step 7） |
| `factor_engine/signal_factor.py` | 因子整合與訊號生成 | ✅ 已實作（Step 7） |
| `analysis/performance_analyzer.py` | 績效指標計算 | ✅ 已實作（Step 8） |

**待擴充功能**：
- 歷史數據一次性預載入機制（Phase 1 優化）
- 簡單規則策略引擎（因子投票決策）
- 每日收盤後績效計算與記錄

---

#### Phase 2：引入 RL，維持 Walk-Forward 框架

**核心概念**：
- RL 不是預測價格，而是學習「何時加碼/減碼/降風險」
- Walk-Forward 架構不變，只把決策引擎從 if/else 升級為 RL

**J-GOD 系統對映**：

| 系統模組 | 對應功能 | 狀態 |
|---------|---------|------|
| `rl_engine/jgod_env.py` | RL 環境（gymnasium.Env） | 規劃中（文件已有規格） |
| `rl_engine/reward_engine.py` | Reward 計算（含 MDD 懲罰、F_Internal 懲罰） | 規劃中（文件已有規格） |
| `rl_engine/memory_engine.py` | Replay Buffer、序列記憶 | 規劃中（文件已有規格） |
| `pipeline/walk_forward_simulator.py` | 整合 RL Agent 到 Walk-Forward 流程 | 需擴充 |

**整合點**：
- `WalkForwardSimulator.run_simulation()` 中，`update_with_factors` 改為 RL Agent 輸出動作

---

#### Phase 3：虛擬實盤 → 階段性實盤

**核心概念**：
- 用 2025 真實資料跑相同流程，但不下真金
- 確認穩定後，再階段性加碼真實倉位

**J-GOD 系統對映**：

| 系統模組 | 對應功能 | 狀態 |
|---------|---------|------|
| （規劃中）`execution/paper_trading_engine.py` | 虛擬下單、滑價模擬、PnL 追蹤 | 待實作 |
| （規劃中）`execution/order_router.py` | 智能訂單路由、TCA 預測 | 待實作 |

---

### 二、成本優化策略：訊號預生成與集中式模型迭代

**核心概念**：
- 階段 A：數據與訊號預生成（低成本、高效率）
- 階段 B：集中式學習與模型修復（高效率、成本可控）

**J-GOD 系統對映**：

| 優化策略 | 對應模組 | 實施方式 |
|---------|---------|---------|
| **數據撈取集中化** | `pipeline/data_loader.py` | 一次性載入所有歷史數據，存入內部數據庫 |
| **預測模型集中運行** | `factor_engine/*.py` | 本地計算因子，無 Token 成本 |
| **結果記錄** | `analysis/performance_analyzer.py` | 記錄 `Predicted_Action`、`Actual_Price`、`Daily_PnL` |
| **集中式學習觸發** | （規劃中）`diagnostic/analyzer.py` | 每 5 天或觸發條件時，才進行模型重訓 |

**成本效益對比**：

| 項目 | 原本設計 | 優化後設計 | 節省成本 |
|------|---------|-----------|---------|
| 數據撈取 | 每天呼叫 API | 一次性預載入 | 零 API 延遲、減少 API 呼叫次數 |
| 模型調參 | 每天重訓 | 每 5 天或觸發時重訓 | 節省 80% 的 Token 和運算成本 |
| 學習穩定度 | 單日結果影響 | 5 天累積結果 | 提高穩定性（避免單日極端值） |

---

### 三、四項智慧優化策略

#### 3.1 故障單元隔離與修復 (Modular Fault Isolation)

**核心概念**：
- 診斷：追溯每個因子和時間框架的單獨 PnL 貢獻
- 隔離：找出績效惡化最嚴重的單一模型單元
- 修復：只重訓故障單元，其他健康模型繼續運行

**J-GOD 系統對映**：

| 系統模組 | 對應功能 | 實施方式 |
|---------|---------|---------|
| `analysis/performance_analyzer.py` | 績效指標計算 | 需擴充：按因子分解 PnL 貢獻 |
| （規劃中）`diagnostic/analyzer.py` | 誤差歸因分析 | 追溯失敗根因到單一因子 |
| `pipeline/walk_forward_simulator.py` | 多 period × symbol 績效收集 | 已支援，需擴充因子層級分析 |

**修復觸發邏輯**：
```python
# 當總體績效惡化時
if sharpe_ratio < 0.5:
    # 診斷：分解各因子貢獻
    factor_contributions = analyze_factor_contributions(results)
    
    # 隔離：找出最差因子
    worst_factor = min(factor_contributions, key=lambda x: x.sharpe)
    
    # 修復：只重訓該因子
    if worst_factor.sharpe < -0.5:
        retrain_factor(worst_factor.name)
```

---

#### 3.2 動態性能驅動觸發 (Dynamic Performance Trigger)

**核心概念**：
- 不等待固定 5 天週期
- 當 3 日 Max DD 超過閾值時，立即觸發修復

**J-GOD 系統對映**：

| 系統模組 | 對應功能 | 實施方式 |
|---------|---------|---------|
| `analysis/performance_analyzer.py` | Max Drawdown 計算 | ✅ 已實作 |
| （規劃中）`diagnostic/analyzer.py` | 動態觸發邏輯 | 監控近 3 日累積 PnL 的 Max DD |
| `pipeline/walk_forward_simulator.py` | 績效持續監控 | 需擴充：即時檢查觸發條件 |

**觸發條件示例**：
```python
# 動態監控
recent_3day_dd = calculate_recent_drawdown(daily_returns, days=3)

if recent_3day_dd < -0.005:  # -0.5% 閾值
    # 立即觸發修復，不等待固定週期
    trigger_immediate_repair()
    reset_learning_cycle()  # 重置 5 天計時
```

---

#### 3.3 訊號歷史資料庫 (Signal Repository for Tuning)

**核心概念**：
- 儲存所有因子分數和最終訊號
- 快速參數優化，無需重新計算因子

**J-GOD 系統對映**：

| 系統模組 | 對應功能 | 實施方式 |
|---------|---------|---------|
| `pipeline/data_loader.py` | 因子快取介面 | ✅ 已實作 Protocol |
| （規劃中）`storage/signal_repository.py` | 訊號資料庫 | 儲存每日因子分數、訊號 |
| （規劃中）`optimizer/parameter_tuner.py` | 快速調參引擎 | 從資料庫載入，套用新參數，瞬間得到新 PnL |

**資料庫結構建議**：
```python
# 每天記錄
SignalCacheEntry:
    date: date
    symbol: str
    factors: Dict[str, float]  # F_C, F_Inertia, F_Signal 等
    signal: FSignalFactor
    actual_price: float
    daily_pnl: float
```

---

#### 3.4 影子學習與 A/B 測試 (Shadow Learning and A/B Testing)

**核心概念**：
- 新模型先在影子環境運行 5 天
- 比較新舊模型表現，只有新模型明顯更好才切換

**J-GOD 系統對映**：

| 系統模組 | 對應功能 | 實施方式 |
|---------|---------|---------|
| `pipeline/walk_forward_simulator.py` | Walk-Forward 執行 | 需擴充：支援雙模型並行 |
| （規劃中）`rl_engine/shadow_agent.py` | 影子 Agent | 新模型在虛擬帳戶中運行 |
| `analysis/performance_analyzer.py` | 績效比較 | 需擴充：比較兩個模型的 Sharpe、MDD |

**切換條件示例**：
```python
# 5 天影子學習後
if (new_model.sharpe > old_model.sharpe + 0.2) or \
   (new_model.max_drawdown < old_model.max_drawdown * 0.5):
    # 自動切換到新模型
    switch_to_new_model()
```

---

### 四、四項理論補強邏輯

#### 4.1 市場機制轉換偵測器 (Regime-Switching Filter)

**核心概念**：
- 主動監控市場波動性和相關性
- 偵測到 Regime Switch 時，立即降風險

**J-GOD 系統對映**：

| 系統模組 | 對應功能 | 實施方式 |
|---------|---------|---------|
| （規劃中）`macro/market_regime_detector.py` | Regime 偵測 | 追蹤 VIX 代理、板塊相關性 |
| `factor_engine/signal_factor.py` | 訊號生成 | 需整合 Regime 資訊 |
| （規劃中）`rl_engine/action_constraint_engine.py` | 行為限制 | 根據 Regime 自動縮小槓桿 |

**觸發邏輯**：
```python
# 監控市場機制
volatility_proxy = calculate_volatility_proxy(recent_data)
sector_correlation = calculate_sector_correlation()

if volatility_proxy > 2.0 * long_term_avg or sector_correlation < threshold:
    # 立即進入低風險模式
    enter_low_risk_mode()
    # 強制縮小所有部位
    reduce_all_positions(ratio=0.5)
    # 暫停學習引擎
    pause_learning_engine()
```

---

#### 4.2 動態風險預算分配 (Dynamic Risk Budgeting)

**核心概念**：
- 部位大小與 AI 信心度掛鉤
- 根據滾動 Sharpe Ratio 動態調整資金使用比例

**J-GOD 系統對映**：

| 系統模組 | 對應功能 | 實施方式 |
|---------|---------|---------|
| `analysis/performance_analyzer.py` | 績效指標計算 | ✅ 已實作 Sharpe、MDD |
| （規劃中）`risk/dynamic_budget.py` | 動態風險預算 | 基於滾動 Sharpe 計算部位大小 |
| `factor_engine/signal_factor.py` | 訊號生成 | 需整合風險預算資訊 |

**計算邏輯示例**：
```python
# 計算動態風險預算
rolling_sharpe = calculate_rolling_sharpe(recent_30days)

if rolling_sharpe > 1.5:  # 歷史高位
    risk_budget = 1.0  # 100% 資金使用
elif rolling_sharpe < 0.5:  # 警戒線
    risk_budget = 0.3  # 30% 資金使用
else:
    risk_budget = 0.5  # 50% 資金使用

# 應用風險預算
max_position_size = base_size * risk_budget
```

---

#### 4.3 數據質量保證與緊急停機 (Data Quality Assurance, DQA)

**核心概念**：
- 在數據進入因子引擎前檢查
- 極端變動或缺失數據時，立即停機

**J-GOD 系統對映**：

| 系統模組 | 對應功能 | 實施方式 |
|---------|---------|---------|
| （規劃中）`data_feed/data_validator.py` | 數據驗證 | 檢查極端變動、日期連續性 |
| `pipeline/data_loader.py` | 數據載入 | 需整合 DQA 邏輯 |
| （規劃中）`system/emergency_halter.py` | 緊急停機 | 當 DQA 失敗時，停止所有決策 |

**檢查邏輯示例**：
```python
# DQA 檢查
def validate_data(price_data):
    # 檢查極端變動
    daily_change = abs((price_today - price_yesterday) / price_yesterday)
    if daily_change > 0.15:  # 15% 極端變動
        # 檢查是否有新聞事件佐證
        if not has_news_event(today):
            raise DataQualityError("極端價格變動，無新聞佐證")
    
    # 檢查日期連續性
    if has_missing_trading_days(price_data):
        raise DataQualityError("日期序列不連續")
    
    return True
```

---

#### 4.4 CEO/Veto Override Protocol (人機最終決策權)

**核心概念**：
- 三個層級的 Veto 權限
- 所有人為介入都記錄並回饋給 AI 學習

**J-GOD 系統對映**：

| 系統模組 | 對應功能 | 實施方式 |
|---------|---------|---------|
| （規劃中）`control/veto_engine.py` | Veto 管理 | 三個層級的人為介入 |
| `jgod/war_room/war_room_app.py` | UI 介面 | 需新增 Veto 按鈕 |
| （規劃中）`audit/decision_log.py` | 決策審計日誌 | 記錄所有 Veto 決策 |

**Veto 層級定義**：
```python
class VetoLevel(Enum):
    LEVEL_1_SOFT = "soft"  # 忽略 AI 決策，當日空手
    LEVEL_2_HARD = "hard"  # 立即清倉，24 小時安全鎖定
    LEVEL_3_RESET = "reset"  # 全面重啟，強制重訓所有模型
```

---

### 五、三大嚴謹性補強機制

#### 5.1 延遲獨立樣本測試 (Delayed Out-of-Sample Validation)

**核心概念**：
- 隔離一段「處女數據區間」（例如 2025 Q1）
- 在所有滾動訓練完成後，進行一次性盲測

**J-GOD 系統對映**：

| 系統模組 | 對應功能 | 實施方式 |
|---------|---------|---------|
| `pipeline/walk_forward_config.py` | 時間切片配置 | 需擴充：支援數據隔離配置 |
| `pipeline/walk_forward_simulator.py` | Walk-Forward 執行 | 需擴充：支援延遲 OOS 測試模式 |
| `analysis/performance_analyzer.py` | 績效分析 | 需擴充：比較訓練期 vs 延遲 OOS 期績效 |

**實施邏輯示例**：
```python
# 配置中隔離數據
config = WalkForwardConfig(
    training_periods=[...],  # 2024 年滾動
    delayed_oos_period=WalkForwardPeriod(
        train_start_ts=0,  # 不使用
        train_end_ts=0,
        oos_start_ts=2025_01_01,
        oos_end_ts=2025_03_31,
    ),
    use_delayed_oos=True,  # 啟用延遲 OOS
)

# 執行延遲 OOS 測試
final_model = walk_forward_simulator.get_final_model()
oos_results = final_model.predict(delayed_oos_period)
```

---

#### 5.2 實戰滑價與延遲成本模擬 (Execution Cost Simulation)

**核心概念**：
- 在績效計算中強制加入手續費、交易稅、滑價成本
- 確保策略在真實成本下仍能盈利

**J-GOD 系統對映**：

| 系統模組 | 對應功能 | 實施方式 |
|---------|---------|---------|
| `analysis/performance_analyzer.py` | 績效分析 | 需擴充：整合執行成本參數 |
| （規劃中）`execution/cost_simulator.py` | 成本模擬器 | 計算手續費、稅、滑價 |
| `pipeline/walk_forward_simulator.py` | Walk-Forward 執行 | 需擴充：在 PnL 計算中扣除成本 |

**成本參數配置**：
```python
cost_config = ExecutionCostConfig(
    commission_rate=0.0015,  # 0.15% 手續費
    tax_rate=0.0,  # 台股免稅（或視情況設定）
    slippage_rate=0.0002,  # 0.02% 滑價
    total_cost_per_trade=0.0017,  # 總成本
)

# 在績效計算中扣除
net_pnl = gross_pnl - (cost_config.total_cost_per_trade * abs(position_change))
```

---

#### 5.3 嚴格時間戳記隔離與洩漏防護 (Look-Ahead Guardrail)

**核心概念**：
- 嚴格執行因子計算的單向時間流
- 防止「未來函數」數據洩漏

**J-GOD 系統對映**：

| 系統模組 | 對應功能 | 實施方式 |
|---------|---------|---------|
| `pipeline/walk_forward_simulator.py` | Walk-Forward 執行 | 需擴充：時間戳記檢查邏輯 |
| `factor_engine/*.py` | 因子計算 | 需確保：只使用歷史數據 |
| （規劃中）`diagnostic/lookahead_detector.py` | 數據洩漏偵測器 | 檢查因子計算是否取用未來數據 |

**防護邏輯示例**：
```python
# 在因子計算前檢查
def compute_factor_at_t(factor_engine, timestamp_t):
    # 確保只使用 t 之前的數據
    available_data = filter_data_by_time(data, max_timestamp=timestamp_t - 1)
    
    # 檢查是否有未來數據洩漏
    if has_future_data(available_data, timestamp_t):
        raise LookAheadError("檢測到未來數據洩漏！")
    
    # 計算因子
    return factor_engine.compute(available_data)
```

---

### 六、三大最終理論補強

#### 6.1 參數敏感度分析與策略崩潰成本

**核心概念**：
- 測試參數周圍的穩定性
- 只有參數在穩定區間才採用

**J-GOD 系統對映**：

| 系統模組 | 對應功能 | 實施方式 |
|---------|---------|---------|
| （規劃中）`optimizer/parameter_sensitivity.py` | 參數敏感度分析 | 測試參數 ±5% 範圍內的績效 |
| `analysis/performance_analyzer.py` | 績效分析 | 需擴充：比較不同參數下的 Sharpe |

---

#### 6.2 風險調整後的資本成本 (RAROC Logic)

**核心概念**：
- 計算淨年化收益（扣除無風險利率）
- 判斷策略是否值得動用資金

**J-GOD 系統對映**：

| 系統模組 | 對應功能 | 實施方式 |
|---------|---------|---------|
| `analysis/performance_analyzer.py` | 績效分析 | 需擴充：計算 RAROC、淨 CAGR |
| （規劃中）`risk/raroc_calculator.py` | RAROC 計算器 | 計算風險調整後的資本成本 |

---

#### 6.3 決策與修復的審計追蹤

**核心概念**：
- 不可篡改的審計日誌
- 詳細記錄所有決策和修復過程

**J-GOD 系統對映**：

| 系統模組 | 對應功能 | 實施方式 |
|---------|---------|---------|
| （規劃中）`audit/decision_logger.py` | 決策日誌器 | 記錄所有決策、修復、Veto |
| （規劃中）`audit/audit_trail.py` | 審計追蹤系統 | 不可篡改的決策歷史 |

---

## 🎯 系統健康檢查流程

當您說「啟動萬物修復法則」或「檢查系統健康」時，系統應執行：

### 1. 多時間框架績效檢查

```python
# 檢查不同 period 的績效
for period in walk_forward_periods:
    metrics = performance_analyzer.analyze(period)
    
    # 檢查指標
    if metrics.sharpe_ratio < 0.5:
        alert(f"Period {period}: Sharpe 異常低 ({metrics.sharpe_ratio})")
    if metrics.max_drawdown > 0.2:
        alert(f"Period {period}: 最大回檔過大 ({metrics.max_drawdown})")
```

### 2. 因子失效檢測

```python
# 檢查各因子的貢獻度
factor_contributions = analyze_factor_contributions(results)

for factor in factor_contributions:
    if factor.sharpe < 0:  # 負貢獻
        alert(f"因子 {factor.name} 持續負貢獻 (Sharpe={factor.sharpe})")
        suggest(f"考慮降低權重或移除因子 {factor.name}")
```

### 3. 數據洩漏檢測

```python
# 檢查是否有未來數據洩漏
if lookahead_detector.has_lookahead_bias(factor_history):
    alert("檢測到數據洩漏！請檢查因子計算邏輯")
    suggest("修正因子計算，確保只使用歷史數據")
```

### 4. 提出修復建議

根據診斷結果，自動生成修復建議：

- **調參數**：調整特定因子的權重（例如：降低失效因子權重）
- **重訓**：重新擬合 PCA、更新 RL 權重（只針對失效因子）
- **降權重**：降低失效因子的重要性（例如：weight * 0.5）
- **暫停使用**：完全停用失效的因子或模型

---

## 📊 現有模組擴充建議

### 已實作模組（需擴充）

| 模組 | 當前狀態 | 建議擴充功能 |
|------|---------|-------------|
| `pipeline/walk_forward_simulator.py` | ✅ 基礎架構 | - 支援延遲 OOS 測試<br>- 支援雙模型影子學習<br>- 動態觸發修復邏輯 |
| `analysis/performance_analyzer.py` | ✅ 基礎指標 | - 按因子分解 PnL 貢獻<br>- 整合執行成本<br>- RAROC 計算 |
| `pipeline/data_loader.py` | ✅ Protocol 定義 | - 一次性批量載入歷史數據<br>- 訊號歷史資料庫儲存 |

### 待實作模組（規劃中）

| 模組 | 對應補強機制 | 優先級 |
|------|-------------|--------|
| `diagnostic/analyzer.py` | 故障單元隔離、誤差歸因 | 🔴 高 |
| `storage/signal_repository.py` | 訊號歷史資料庫 | 🟡 中 |
| `data_feed/data_validator.py` | 數據質量保證 (DQA) | 🔴 高 |
| `risk/dynamic_budget.py` | 動態風險預算分配 | 🟡 中 |
| `macro/market_regime_detector.py` | 市場機制轉換偵測 | 🟡 中 |
| `execution/cost_simulator.py` | 執行成本模擬 | 🟢 低 |
| `diagnostic/lookahead_detector.py` | 數據洩漏偵測 | 🔴 高 |
| `audit/decision_logger.py` | 決策審計日誌 | 🟡 中 |

---

## 💡 設計原則

在設計/調整任何 Walk-Forward 相關邏輯時，都要問：

1. **這段程式碼對應哪一種「補強機制」？**
   - 成本優化？
   - 智慧學習？
   - 嚴謹性驗證？

2. **它如何幫助系統在偏離時回到合理狀態？**
   - 是否提供監控指標？
   - 是否自動調整參數？
   - 是否降風險？

3. **它會用什麼指標來觸發修復？**
   - Sharpe、Max Drawdown、Hit Rate？
   - 參數敏感度？
   - 數據洩漏檢測？

---

*本文件作為 J-GOD 系統開發的核心指導原則，所有 Walk-Forward 相關設計都應遵循「滾動式分析」的精神。*

