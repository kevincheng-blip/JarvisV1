# 萬物修復法則 × J-GOD 系統對映關係

> **整理日期**：2024-11-28  
> **來源文件**：`docs/股市大自然萬物修復法則_AI知識庫版_v1.md`

---

## 📚 核心結構概述

《股市大自然萬物修復法則》提出「三大不可分割、持續運行的模態」，對應市場的「熵增」與 AI 的「反熵」：

### 三大模態

1. **模態 I：認知與記錄（Cognitive State）**
   - 建立真實世界的模型
   - 絕對透明與審計

2. **模態 II：求證與診斷（Diagnostic Cycle）**
   - 尋找「知識的邊界」與「失敗的根因」
   - 誤差分層歸因

3. **模態 III：修復與演化（Evolving Action）**
   - 重寫底層生存法則
   - 知識的自我修復與持續進化

---

## 🔄 四大修復層面 × J-GOD 系統對映

### 一、價格與空間的修復（均值回歸、空間偏離修復）

**核心概念**：
- 價格偏離合理範圍時會自動回歸
- 空間維度的失衡會觸發市場自我調整

**J-GOD 系統對映**：

| 系統模組 | 修復機制 | 觸發指標 | 修復動作 |
|---------|---------|---------|---------|
| **F_CrossAsset** | 跨資產價差 Z-score 監控 | `spread_zscore` 過大（> 2.0 或 < -2.0） | 判斷價格偏離，觸發反向交易訊號 |
| **F_Orderbook** | 流動性深度監控 | `Depth_Zscore < -2.0`（深度稀薄） | 自動縮小下單量，避免價格衝擊 |
| **OrderbookImbalance** | 買賣盤失衡監控 | `OBI` 極端值（接近 ±1） | 預期價格會回歸，產生反向訊號 |

**程式碼位置**：
- `factor_engine/cross_asset_factor.py`：`spread_zscore` 計算
- `factor_engine/orderbook_factor.py`：`Depth_Zscore`、`OBI` 計算
- `rl_engine/action_constraint_engine.py`：根據流動性限制行為空間

**修復觸發條件示例**：
```python
# 當 spread_zscore 超過 2 個標準差 → 價格偏離過大
if abs(spread_zscore) > 2.0:
    # 觸發「空間修復」機制
    # 可能動作：反向交易、減倉、等待回歸
```

---

### 二、時間與週期的修復（多週期、時間到就會修正）

**核心概念**：
- 市場有內在的時間節奏
- 不同時間框架的模型會相互校準
- 「時間到」就會自然修正偏離

**J-GOD 系統對映**：

| 系統模組 | 修復機制 | 觸發指標 | 修復動作 |
|---------|---------|---------|---------|
| **F_InfoTime** | 資訊時間密度監控 | `F_InfoTime` 異常高/低 | 調整 RL 注意力權重，重新分配歷史資訊重要性 |
| **Walk-Forward Pipeline** | 多週期績效監控 | 不同 period 的績效差異 | 識別模型失效，觸發重訓或參數調整 |
| **Transformer RL** | 注意力機制 | 根據 `F_InfoTime` 動態調整 attention weights | 在資訊密度高時，更依賴最近的訊號；密度低時，參考更長歷史 |

**程式碼位置**：
- `factor_engine/info_time_engine.py`：`F_InfoTime` 計算
- `pipeline/walk_forward_simulator.py`：多週期模擬
- `analysis/performance_analyzer.py`：跨 period 績效分析

**修復觸發條件示例**：
```python
# 當 F_InfoTime 異常高 → 市場節奏變化，需要快速反應
if F_InfoTime > 2.0:
    # 觸發「時間修復」機制
    # 動作：增加最近訊號權重，快速遺忘舊資訊
    transformer_attention_weights = adjust_by_info_time(F_InfoTime)
```

---

### 三、系統與模型的修復（Sharpe / DD 監控、自我重訓）

**核心概念**：
- AI 系統持續監控自身表現
- 當 Sharpe 下降、Max Drawdown 擴大時自動診斷
- 透過 DiscrepancyAnalyzer 找出失敗根因，自動調整模型

**J-GOD 系統對映**：

| 系統模組 | 修復機制 | 觸發指標 | 修復動作 |
|---------|---------|---------|---------|
| **PerformanceAnalyzer** | Sharpe / MDD 監控 | `sharpe_ratio < 0.5` 或 `max_drawdown > 0.2` | 觸發診斷流程 |
| **DiscrepancyAnalyzer** | 誤差分層歸因 | `E_Exec`（執行誤差）或 `E_Model`（模型誤差） | 識別失敗類型，提供修復指令 |
| **Reward Engine** | Reward 懲罰機制 | `F_Internal > threshold`（內部衝突） | 自動降低衝突時期的行為激進度 |
| **RL Trainer** | 模型重訓 | 診斷發現特定 O-Factor 失效 | 自動調整因子權重或重新擬合 PCA |

**程式碼位置**：
- `analysis/performance_analyzer.py`：績效指標計算
- `pipeline/walk_forward_simulator.py`：多週期績效收集
- （規劃中）`diagnostic/analyzer.py`：誤差歸因分析
- （規劃中）`rl_engine/reward_engine.py`：Reward 計算與懲罰

**修復觸發條件示例**：
```python
# 當績效指標惡化 → 觸發「系統修復」機制
if sharpe_ratio < 0.5 or max_drawdown > 0.2:
    # 1. 啟動診斷
    diagnosis = discrepancy_analyzer.analyze(results)
    
    # 2. 根據診斷結果修復
    if diagnosis['Failure_Type'] == 'MODEL_PREDICTION':
        # 模型失效：調整失敗因子的權重
        adjust_factor_weight(diagnosis['Root_Cause'])
    elif diagnosis['Failure_Type'] == 'EXECUTION':
        # 執行失效：調整下單策略
        adjust_execution_params()
```

---

### 四、情緒與行為的修復（極端情緒 → 反向修復）

**核心概念**：
- 市場極端情緒（恐慌/貪婪）會自然反轉
- 內部因子衝突時，系統應該降低風險暴露
- 透過 F_Internal 感知系統內部矛盾

**J-GOD 系統對映**：

| 系統模組 | 修復機制 | 觸發指標 | 修復動作 |
|---------|---------|---------|---------|
| **F_Internal** | 內部衝突感知 | `F_Internal > 0.7`（高衝突） | 自動縮小槓桿、降低部位、禁止激進策略 |
| **VIX_Zscore** | 市場恐慌監控 | `VIX_Zscore > 2.5`（極端恐慌） | 觸發熔斷、降槓桿、等待市場恢復 |
| **F_Signal** | 訊號極端值檢測 | `raw_score` 接近 ±1.0（極端訊號） | 可能觸發反向訊號或等待回歸 |
| **ActionConstraintEngine** | 動態行為限制 | `F_Internal` + `VIX_Zscore` 同時異常 | 強制縮小行為空間，避免系統在矛盾中冒進 |

**程式碼位置**：
- （規劃中）`factor_engine/internal_factor.py`：`F_Internal` 計算
- （規劃中）`rl_engine/action_constraint_engine.py`：根據情緒限制行為
- `factor_engine/signal_factor.py`：訊號生成與分桶

**修復觸發條件示例**：
```python
# 當情緒極端或內部衝突 → 觸發「情緒修復」機制
if VIX_Zscore > 2.5 or F_Internal > 0.7:
    # 動作：反向操作或降風險
    # 1. 縮小槓桿
    max_leverage *= 0.3
    
    # 2. 禁止激進策略
    aggressive_allowed = False
    
    # 3. 可能產生反向訊號
    if extreme_sentiment_detected:
        signal_bucket = reverse_signal(signal_bucket)
```

---

## 🔍 修復機制流程圖

```
市場偏離
    ↓
【監控層】
├─ 價格偏離？ → F_CrossAsset.spread_zscore
├─ 時間異常？ → F_InfoTime
├─ 績效惡化？ → PerformanceMetrics (Sharpe, MDD)
└─ 情緒極端？ → VIX_Zscore, F_Internal
    ↓
【診斷層】
DiscrepancyAnalyzer.analyze()
├─ E_Exec（執行誤差）
└─ E_Model（模型誤差）
    ↓
【修復層】
├─ 調整參數（因子權重、下單量）
├─ 重訓模型（重新擬合 PCA、更新 RL 權重）
├─ 降風險（縮小槓桿、減倉）
└─ 暫停使用（失效因子停用）
    ↓
【驗證層】
Walk-Forward 多週期驗證
    ↓
持續監控 → 回到監控層
```

---

## 📊 指標與修復對應表

### 價格/空間修復指標

| 指標 | 正常範圍 | 異常範圍 | 修復動作 |
|------|---------|---------|---------|
| `spread_zscore` | [-1.0, 1.0] | abs > 2.0 | 反向交易、等待回歸 |
| `Depth_Zscore` | [-1.0, 1.0] | < -2.0 | 縮小下單量、被動掛單 |
| `OBI` | [-0.5, 0.5] | 接近 ±1.0 | 預期反轉、反向訊號 |

### 時間修復指標

| 指標 | 正常範圍 | 異常範圍 | 修復動作 |
|------|---------|---------|---------|
| `F_InfoTime` | [0.8, 1.2] | > 2.0 或 < 0.5 | 調整 attention 權重、快速遺忘 |
| Period 績效差異 | 相近 | 差異 > 50% | 重訓模型、調整參數 |

### 系統修復指標

| 指標 | 正常範圍 | 異常範圍 | 修復動作 |
|------|---------|---------|---------|
| `sharpe_ratio` | > 1.0 | < 0.5 | 啟動診斷、重訓模型 |
| `max_drawdown` | < 0.15 | > 0.2 | 降槓桿、暫停交易 |
| `E_Model` | 接近 0 | abs > 500 | 調整失敗因子權重 |
| `E_Exec` | 接近 0 | > 0.001 | 調整下單策略 |

### 情緒修復指標

| 指標 | 正常範圍 | 異常範圍 | 修復動作 |
|------|---------|---------|---------|
| `VIX_Zscore` | [-1.0, 1.0] | > 2.5 | 熔斷、降槓桿、等待恢復 |
| `F_Internal` | < 0.3 | > 0.7 | 縮小行為空間、禁止激進 |
| `raw_score` | [-0.8, 0.8] | 接近 ±1.0 | 反向訊號或等待回歸 |

---

## 🎯 系統健康檢查流程

當您說「啟動萬物修復法則」或「檢查系統健康」時，系統應執行：

### 1. 多時間框架績效檢查

```python
# 檢查不同 period 的績效
for period in walk_forward_periods:
    metrics = performance_analyzer.analyze(period)
    
    # 檢查指標
    if metrics.sharpe_ratio < 0.5:
        alert("Period {period}: Sharpe 異常低")
    if metrics.max_drawdown > 0.2:
        alert("Period {period}: 最大回檔過大")
```

### 2. 因子失效檢測

```python
# 檢查各因子的貢獻度
for factor in o_factors:
    contribution = calculate_factor_contribution(factor, results)
    
    if contribution < 0:  # 負貢獻
        alert(f"因子 {factor} 持續負貢獻")
        suggest("考慮降低權重或移除")
```

### 3. 內部衝突檢測

```python
# 檢查 F_Internal
if F_Internal > 0.7:
    alert("系統內部因子衝突過高")
    suggest("降低槓桿、縮小行為空間")
```

### 4. 提出修復建議

根據診斷結果，自動生成修復建議：

- **調參數**：調整特定因子的權重
- **重訓**：重新擬合 PCA、更新 RL 權重
- **降權重**：降低失效因子的重要性
- **暫停使用**：完全停用失效的因子或模型

---

## 🔗 現有模組對應關係

### 已實作模組

| 模組 | 對應修復層面 | 狀態 |
|------|-------------|------|
| `factor_engine/cross_asset_factor.py` | 價格/空間修復 | ✅ 完成 |
| `factor_engine/info_time_engine.py` | 時間修復 | ✅ 完成 |
| `factor_engine/orderbook_factor.py` | 價格/空間修復 | ✅ 完成 |
| `factor_engine/signal_factor.py` | 情緒修復 | ✅ 完成 |
| `analysis/performance_analyzer.py` | 系統修復 | ✅ 完成 |
| `pipeline/walk_forward_simulator.py` | 系統修復 | ✅ 完成 |

### 待實作模組（根據文件規劃）

| 模組 | 對應修復層面 | 規劃位置 |
|------|-------------|---------|
| `diagnostic/analyzer.py` | 系統修復 | 待實作 |
| `factor_engine/internal_factor.py` | 情緒修復 | 待實作 |
| `rl_engine/reward_engine.py` | 系統修復 | 待實作 |
| `rl_engine/action_constraint_engine.py` | 情緒修復 | 待實作 |

---

## 💡 設計原則

在設計/調整任何因子引擎、Walk-Forward 分析、風控邏輯時，都要問：

1. **這段程式碼對應哪一種「修復」？**
   - 價格/空間修復？
   - 時間修復？
   - 系統修復？
   - 情緒修復？

2. **它如何幫助系統在偏離時回到合理狀態？**
   - 是否提供監控指標？
   - 是否自動調整參數？
   - 是否降風險？

3. **它會用什麼指標來觸發修復？**
   - Sharpe、Max Drawdown、Hit Rate？
   - 偏離度（Z-score）？
   - 內部衝突（F_Internal）？
   - 時間異常（F_InfoTime）？

---

*本文件作為 J-GOD 系統開發的核心指導原則，所有模組設計都應遵循「萬物修復法則」的精神。*

